<?php

/**
 * @file
 * Springboard Group integration with Organic Groups.
 */

require_once __DIR__ . '/includes/springboard_group.commerce_cardonfile.inc';
require_once __DIR__ . '/includes/springboard_group.ctools.inc';
require_once __DIR__ . '/includes/springboard_group.email_wrappers.inc';
require_once __DIR__ . '/includes/springboard_group.entityreference.inc';
require_once __DIR__ . '/includes/springboard_group.field_groups.inc';
require_once __DIR__ . '/includes/springboard_group.fields.inc';
require_once __DIR__ . '/includes/springboard_group.fundraiser.inc';
require_once __DIR__ . '/includes/springboard_group.menu.inc';
require_once __DIR__ . '/includes/springboard_group.og_context.inc';
require_once __DIR__ . '/includes/springboard_group.og_ui.inc';
require_once __DIR__ . '/includes/springboard_group.orders.inc';
require_once __DIR__ . '/includes/springboard_group.pages_default.inc';
require_once __DIR__ . '/includes/springboard_group.page_wrappers.inc';
require_once __DIR__ . '/includes/springboard_group.permissions.inc';
require_once __DIR__ . '/includes/springboard_group.rules.inc';
require_once __DIR__ . '/includes/springboard_group.tokens.inc';
require_once __DIR__ . '/includes/springboard_group.user.inc';
require_once __DIR__ . '/includes/springboard_group.webform.inc';
require_once __DIR__ . '/includes/springboard_group.webform_ab.inc';
require_once __DIR__ . '/includes/springboard_group.wrappers_common.inc';

/**
 * Implements hook_node_info().
 *
 * Define the content type Springboard Group. OG lets you turn any entity
 * into a group, but Springboard Groups is specifically geared to this
 * content type.
 */
function springboard_group_node_info() {
  $items = array(
    'springboard_group' => array(
      'name' => t('Springboard Group'),
      'base' => 'node_content',
      'description' => '',
      'has_title' => '1',
      'title_label' => t('Title'),
      'help' => '',
      'locked' => TRUE,
    ),
  );
  return $items;
}

/**
 * Implements hook_views_api().
 */
function springboard_group_views_api() {
  return array(
    'api' => 3.0,
    'path' => drupal_get_path('module', 'springboard_group') . '/includes/views',
  );
}

/**
 * Implements hook_node_access().
 */
function springboard_group_node_access($node, $op, $account) {

  if ($op == 'view') {
    // Allow access to unpublished actions so that messages can be
    // assigned to them via entity reference prepopulate.
    if (strpos($node->type, 'sba_') !== FALSE) {
      if ($node->status == 0 && user_access('create ' . $node->type . ' content')) {
        return NODE_ACCESS_ALLOW;
      }
    }

    // Limit view access to group nodes.
    if ($node->type == 'springboard_group') {
      if (empty(og_get_groups_by_user())
        && !user_access('administer group')
        && !user_access('create springboard_group content')
        && !user_access('edit any springboard_group content')
        && !user_access('edit own springboard_group content')
      ) {
        return NODE_ACCESS_DENY;
      }
    }
  }

  return NODE_ACCESS_IGNORE;
}

/**
 * Get a list of groupable entity types.
 *
 * Checks to see what entity types have an OG group reference field using the
 * og_springboard_og handler, or in the case of users, a specific field name.
 *
 * Please note that *USERS* have a normal entity reference field that we
 * are counting as a "group" field. Therefore DO NOT use this function
 * without that expectation and its consequences.
 *
 * @return array
 *   An array of groupable entities.
 */
function springboard_group_get_grouped_types() {
  $groups_enabled = &drupal_static(__FUNCTION__);
  if (!isset($groups_enabled)) {
    $groups_enabled = array();
    // Get the fields that exist in the bundle.
    foreach (field_info_fields() as $field_name => $field) {
      if ($field_name == 'user_sb_group_ref') {
        if (springboard_group_users_are_grouped()) {
          $groups_enabled['user']['user'][] = 'user_sb_group_ref';
        }
      }

      if ($field['type'] == 'entityreference' && $field['settings']['handler'] == 'og_springboard_og' && !empty($field['bundles'])) {
        foreach ($field['bundles'] as $entity_type => $bundles) {
          foreach ($bundles as $bundle) {
            $groups_enabled[$entity_type][$bundle][] = $field_name;
          }
        }
      }
    }
  }
  return $groups_enabled;
}

/**
 * Return all groups of the "springboard_group" bundle.
 */
function springboard_group_get_all_springboard_groups() {
  if (!field_info_field(OG_GROUP_FIELD)) {
    return array();
  }

  $query = new EntityFieldQuery();
  $return = $query
    ->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'springboard_group')
    ->fieldCondition(OG_GROUP_FIELD, 'value', 1, '=')
    ->execute();

  return !empty($return['node']) ? array_keys($return['node']) : array();
}

/**
 * Check if a particular node type is grouped.
 *
 * @param $type
 * @param bool $fields
 *
 * @return array|bool
 */
function springboard_group_node_type_is_grouped($type, $fields = FALSE) {
  $group_enabled_field = &drupal_static(__FUNCTION__ . $type . $fields);
  if (!isset($group_enabled_field)) {
    $group_enabled_field = og_get_group_audience_fields('node', $type, 'node', 'springboard_group');
  }
  if (!$fields) {
    return (bool) $group_enabled_field;
  }
  else {
    return $group_enabled_field;
  }
}

/**
 * Get the group ids from the OG form element.
 *
 * Used during Ajax requests triggered by the OG element and in validation
 * hooks. GIDs are pulled from form_state['values'] not from the
 * form element's #default_value.
 */
function springboard_group_get_gids_from_element($form, $form_state) {
  if (isset($form['#node']->type)) {
    $type = $form['#node']->type;
  }
  else {
    $type = $form['#entity_type'];
  }
  $language = $form['og_group_ref_' . substr($type, 0, 19)]['#language'];
  $option = $form_state['values']['og_group_ref_' . substr($type, 0, 19)][$language];
  $gids = isset($option[0]['target_id']) ? $option : [];
  foreach ($gids as $key => $gid) {
    $gids[$key] = $gid['target_id'];
  }
  return $gids;
}


/**
 * Implements hook_form_FORMID_alter().
 *
 * Alter the form on the springboard group content type.
 */
function springboard_group_form_springboard_group_node_form_alter(&$form, &$form_state) {
  // Change some of the defaults on the addressfield.
  if (!empty($form['field_sb_group_address'])) {
    $form['field_sb_group_address']['#type'] = 'fieldset';
    $form['field_sb_group_address']['#collapsible'] = TRUE;
    $form['field_sb_group_address']['#collapsed'] = TRUE;
    $form['field_sb_group_address']['#title'] = t('Address');
    $form['field_sb_group_address'][$form['field_sb_group_address']['#language']][0]['#title'] = '';
  }
  // Add a valdiate hook.
  $form['#validate'][] = 'springboard_group_springboard_group_node_form_validate';
}

/**
 * Validate the email address.
 */
function springboard_group_springboard_group_node_form_validate($form, &$form_state) {
  $email = $form_state['values']['field_sb_group_cemail'][$form['field_sb_group_cemail']['#language']][0];
  if (!empty($email['value'])) {
    $valid = valid_email_address($email['value']);
    if (!$valid) {
      form_set_error('field_sb_group_cemail', t('Invalid email address in contact field.'));
    }
  }
}

/**
 * Implements hook_form_node_form_alter().
 *
 * Intervene on the node add/edit forms of all types that use the
 * springboard group OG widget.
 */
function springboard_group_form_node_form_alter(&$form, &$form_state) {
  $fields = og_get_group_audience_fields('node', $form['#node']->type, 'node', 'springboard_group');
  if (!empty($fields)) {

    // Change the group field from a multiple select to a single select,
    // if single select is enabled in Springboard Group settings.
    springboard_group_set_single_selector($form, $fields);

    // Add ajax callback to the groups field so we can validate newly
    // selected groups.
    $language = $form['og_group_ref_' . substr($form['#node']->type, 0, 19)]['#language'];
    $form['og_group_ref_' . substr($form['#node']->type, 0, 19)][$language][0]['default']['#ajax'] = array(
      'callback' => 'springboard_group_og_group_field_ajax_callback',
    );

    // Don't send the IDS of token table fields during ajax requests to avoid
    // max_input_vars problem.
    $form['#attached']['js'][] = drupal_get_path('module', 'springboard_group') . '/js/before-serialize.js';

    // Set the context for any entity reference fields on this form.
    // Not currently used, but would be required for p2p or any other
    // content type that uses entity reference fields (apart from actions
    // and wrappers) to reference grouped content.
    springboard_group_context_entityreference($form, $form_state);

    // Set up the validation modal window parameters.
    springboard_group_prepare_validation_modal($form, $form_state);

    // Add the validation handlers to the form.
    springboard_group_load_ajax_validation_handlers($form, $form_state);

    $form['#validate'][] = 'springboard_group_node_form_validate';

    // Add the available group-related tokens to the Page Wrappers body description
    if($form_state['node']->type == 'page_wrapper') {
      $form['page_wrappers_html_template'][$language][0]['#description'] .= ' <div class="sb-og-tokens-message">Group field values may be utilized with the following tokens: [springboard_groups:group_names], [springboard_groups:field_sb_group_address], [springboard_groups:field_sb_group_logo], [springboard_groups:field_sb_group_cname], [springboard_groups:field_sb_group_cemail]</div>';
    }
  }
}

/**
 * Validate the node form submission.
 */
function springboard_group_node_form_validate(&$form, &$form_state) {
  // Minor tweak to default OG language.
  if (isset($_SESSION['messages']['error'])) {
    foreach ($_SESSION['messages']['error'] as $key => $message) {
      if (strpos($message, 'You must select one or more groups for this content') != FALSE) {
        $_SESSION['messages']['error'][$key] = t('You must select a group for this content.');
      }
    }
  }
}

/**
 * Ajax Callback.
 *
 * Handles pagewrappers and payment gateway selector updates when the group
 * selector is changed on node edit forms.
 *
 * Displays message in a cTools modal when a new group selection conflicts
 * with an entity's grouped-owned assets: page wrappers, email wrappers, message
 * targets, ab tests, and vice versa.
 */
function springboard_group_og_group_field_ajax_callback(&$form, &$form_state) {

  $ajax = array(
    '#type' => 'ajax',
    '#commands' => array(),
  );

  ctools_include('ajax');
  ctools_include('modal');

  // Update the pagewrapper fieldset.
  if (!empty($form['springboard_display']['page_wrappers_settings']['page_wrappers'])) {
    $ajax['#commands'][] = ajax_command_replace("#page-wrappers-assignments", render($form['springboard_display']['page_wrappers_settings']['page_wrappers']));
  }

  // Update the entire gateways fieldset.
  if (!empty($form['payment_methods']['gateways'])) {
    $ajax['#commands'][] = ajax_command_replace("#springboard-groups-payment-ajax-wrapper", render($form['payment_methods']['gateways']));
  }

  // P2P.
  if (!empty($form['#fieldgroups']['group_tabs'])) {
    //$ajax['#commands'][] = ajax_command_replace("#field-group-htabs-wrapper ", render($form['#fieldgroups']['group_tabs']));
  }

  // Show messages about conflicting page assets after a new group is selected.
  $messages = $form_state['group_ajax_messages'];
  if (!empty($messages)) {
    $list = implode('<br /><br />', $form_state['group_ajax_messages']);
    $ajax['#commands'][] = ctools_modal_command_display(t('Group asset update'), $list);
  }

  return $ajax;
}

/**
 * Prepare the validation modal window.
 */
function springboard_group_prepare_validation_modal(&$form, &$form_state) {
  // Set up our group validation modal message window which will display after
  // ajax reload if there is a group conflict.
  ctools_include('modal');
  ctools_modal_add_js();
  $settings['CToolsModal']['modalSize'] = array(
    'type' => 'scale',
    'width' => .6,
    'height' => .6,
  );
  $settings['CToolsModal']['modalOptions'] = array(
    'opacity' => '.55',
    'background' => '#ccc',
  );
  drupal_add_js($settings, 'setting');
  $form_state['group_ajax_messages'] = [];
}

/**
 * Add validation functions to the node form by extending the form_alter hook.
 */
function springboard_group_load_ajax_validation_handlers(&$form, &$form_state) {

  $callback = !empty($form_state['triggering_element']['#ajax']['callback']) ? $form_state['triggering_element']['#ajax']['callback'] : '';

  if (isset($form['#node']->type)) {

    $type = $form['#node']->type;
    if (fundraiser_is_donation_type($type) && springboard_group_rules_config_are_grouped()) {
      springboard_group_fundraiser_node_form__alter($form, $form_state, $callback);
    }
    if (module_exists('page_wrappers')
      && springboard_group_node_type_is_grouped('page_wrapper')
      && (_page_wrappers_enabled_type($form['#node']) || $type == 'page_wrapper')) {
      springboard_group_page_wrappers_node_form__alter($form, $form_state, $callback);
    }

    if (!empty($form_state['values'])) {
      if ($callback != 'springboard_group_og_group_field_ajax_callback') {
        return;
      }
      $webform_types = variable_get('webform_node_types');
      if (module_exists('email_wrappers')
        && in_array($type, $webform_types)
        && springboard_group_node_type_is_grouped('email_wrapper')) {
        springboard_group_email_wrappers_node_form__alter($form, $form_state);
      }
      if (module_exists('webform_ab')
        && springboard_group_node_type_is_grouped('webform_ab')
        && ($type == 'webform_ab' || in_array($type, $webform_types))) {
        springboard_group_webform_ab_node_form__alter($form, $form_state);
      }
      if (module_exists('springboard_group_advocacy')
        && springboard_advocacy_is_action_type($type)
        && springboard_group_node_type_is_grouped($type)) {
        springboard_group_advocacy_action_targets_form__alter($form, $form_state);
      }
    }
  }
  else {
    $type = $form['#entity_type'];
    if ($type == 'rules_config') {
      springboard_group_rules_config_form__validate($form, $form_state, $callback);
    }
    if ($type == 'commerce_order') {
      springboard_group_commerce_order_form__validate($form, $form_state, $callback);
    }
  }

}

/**
 * Implements hook_field_widget_form_alter().
 *
 * Instead of having a separate "mock" field for "groups you don't belong to"
 * we'll put all options in the main widget for sufficiently permissioned
 * national group admin.
 *
 * @see OgSpringboardOgSelectionHandler
 * @see og_field_widget_form()
 *
 * Also fix a drupal ajax bug in multiple select form items.
 */
function springboard_group_field_widget_form_alter(&$element, &$form_state, $context) {

  if (isset($context['field']['settings']['handler']) && $context['field']['settings']['handler'] == 'og_springboard_og') {
    // If the og reference field is using our custom selection handler,
    // remove the admin "groups you are not of member of" field.
    if (user_access('administer group') && !empty($element['admin'])) {
      $element['admin']['#access'] = FALSE;
      // Set the value of the default field to the default value of the admin
      // field if there are values present.
      if (!empty($element['admin']['#default_value']) && empty($element['default']['#default_value'])) {
        $element['default']['#default_value'] = $element['admin']['#default_value'];
      }
      elseif (!empty($element['admin']['#default_value']) && is_array($element['default']['#default_value'])) {
        $element['default']['#default_value']  = array_merge($element['default']['#default_value'], $element['admin']['#default_value']);
      }
      $element['admin']['#default_value'] = [];
    }

    // During the ajax callback, when multiple selections are enabled,
    // the value of $form_state['input']['og_group_ref_{name}'] is, for some
    // unknown reason, a comma-separated string of group IDs instead of an
    // indexed array. This causes an illegal choice error. Here we reset it
    // as an array in the #value property so that _form_validate() does
    // not choke.
    // @see https://www.drupal.org/node/153774 for fix.
    // @see https://www.drupal.org/node/2266303 for description of
    // another possible fix via jQuery Update module.
    if (isset($element['#type']) && $element['#type'] == 'select' && $element['#multiple'] == TRUE) {
      if (!isset($element['#element_validate']) || !is_array($element['#element_validate'])) {
        $element['#element_validate'] = array();
      }
      $element['#element_validate'] = array_merge(array('springboard_group_element_select_validate'), $element['#element_validate']);
      if (!isset($element['#after_build']) || !is_array($element['#after_build'])) {
        $element['#after_build'] = array();
      }
      $element['#after_build'] = array_merge(array('springboard_group_element_after_build'), $element['#after_build']);
    }
  }
}

/**
 * Drupal ajax bug fix for multiple select form elements.
 *
 * @see springboard_group_field_widget_form_alter()
 */
function springboard_group_element_select_validate(&$element, &$form_state) {
  if (isset($element['#ajax'])) {
    $groups_values = $element['#value'];
    if (!empty($groups_values) && is_array($groups_values)) {
      $groups = reset($groups_values);
      if ($groups && strpos($groups, ',') !== FALSE) {
        $selected_groups = explode(',', $groups);
        $groups_values = array();
        foreach ($selected_groups as $selected_group) {
          $groups_values[$selected_group] = $selected_group;
        }
        $element['#value'] = $groups_values;
      }
    }
    form_set_value($element, $groups_values, $form_state);
  }
}

/**
 * Drupal ajax bug fix for multiple select form elements.
 *
 * @see springboard_group_field_widget_form_alter()
 */
function springboard_group_element_after_build($element, &$form_state) {
  springboard_group_element_select_validate($element, $form_state);
  return $element;
}

/**
 * Optionally change the OG group field from multiple select to single select.
 *
 * On node forms. Doing it here instead of in field config allows us to preserve
 * an unlimited cardinality, which OG basically always assumes is the case.
 * Limiting the cardinality to 1 would cause errors when different users
 * attempt to reassign a node to a different group when it has a membership
 * already assigned by different user, even though the original record in the
 * og_membership table would be removed.
 *
 * Also, we change the title and description, and unset the "none" option
 * if the user only belongs to one group is not not an og administrator.
 *
 * @param array $form
 *   The form on which the group selector appears.
 * @param array $fields
 *   An array of group reference fields.
 */
function springboard_group_set_single_selector(&$form, $fields) {
  $grouped_entities = springboard_group_get_grouped_types();
  $show_none = springboard_group_check_none_option($form);
  foreach ($fields as $key => $field) {
    $field_name = $key;
    foreach ($grouped_entities as $entity => $bundle) {
      foreach ($bundle as $bundle_name => $og_field) {
        if (in_array($key, $og_field)) {
          $form[$field_name]['#type'] = 'fieldset';
          $form[$field_name]['#collapsible'] = TRUE;
          $form[$field_name]['#collapsed'] = FALSE;
          $form[$field_name]['#title'] = variable_get('springboard_group_name', t('Springboard Groups'));
          $form[$field_name][$form[$field_name]['#language']]['#title'] = '';
          $form[$field_name][$form[$field_name]['#language']][0]['default']['#title'] = t('Group');
          $form[$field_name][$form[$field_name]['#language']][0]['default']['#description'] = t('Associate this content with a group.');
          $form[$field_name][$form[$field_name]['#language']][0]['default']['#multiple'] = variable_get('og_' . $bundle_name . '_multiple', 0);
          $options =& $form[$field_name][$form[$field_name]['#language']][0]['default']['#options'];
          if (count($options) > 1 && isset($options['_none'])) {
            if (!$show_none) {
              unset($options['_none']);
            }
          }
        }
      }
    }
  }
}

/**
 * Check if the user can post outside of the group context.
 *
 * If not, remove the "_none" option, which would cause a validation error
 * in any case. Saves an "oops" step in node creation.
 *
 * @param array $form
 *   The form array.
 *
 * @return bool
 *   Whether the user can use the "none" selection option.
 */
function springboard_group_check_none_option($form) {
  global $user;
  $show_none_option = TRUE;
  $entity_type = $form['#entity_type'];

  $account = user_load($user->uid);
  $bundle = $form['#bundle'];
  $entity = $form['#entity'];
  list($id) = entity_extract_ids($entity_type, $entity);

  $op = empty($id) ? 'create' : 'update';

  if ($entity_type == 'node') {
    $node = empty($id) ? $bundle : $entity;
    // We call node_node_access() directly as we just want to check the
    // permissions using user_acces().
    if (node_node_access($node, $op, $account)) {
      // User has site-wide permissions to create or edit the node.
      return $show_none_option;
    }
  }
  elseif (entity_access($op, $entity_type, $entity, $account)) {
    // User has site-wide permissions to create or edit the entity.
    return $show_none_option;
  }

  foreach (array_keys(og_get_group_audience_fields($entity_type, $bundle)) as $field_name) {
    // If there is at least one group selected, return.
    if (!empty($form_state['values'][$field_name][LANGUAGE_NONE])) {
      return $show_none_option;
    }
  }
  return FALSE;
}

/**
 * Implements hook_preprocess_page().
 */
function springboard_group_preprocess_page(&$vars) {
  // Add the group context selector to pages.
  springboard_group_context_selector__preprocess_page($vars);
}

/**
 * Implements hook_TAG_query_alter().
 *
 * Don't allow groups in search results for unprivileged users.
 */
function springboard_group_query_node_access_alter(QueryAlterableInterface $query) {

  if (empty($query->alterTags['search_node'])) {
    return;
  }

  if (!empty(og_get_groups_by_user())
    || user_access('administer group')
    || user_access('create springboard_group content')
    || user_access('edit any springboard_group content')
    || user_access('edit own springboard_group content')) {
    return;
  }

  $search = FALSE;
  $node = FALSE;

  foreach ($query->getTables() as $alias => $table) {
    if ($table['table'] == 'search_index') {
      $search = $alias;
    }
    elseif ($table['table'] == 'node') {
      $node = $alias;
    }
  }

  if ($node && $search) {
    $excluded_content_types = array('springboard_group');
    if (!empty($excluded_content_types)) {
      $query->condition($node . '.type', array($excluded_content_types), 'NOT IN');
    }
  }
}

/**
 * Implements hook_page_alter().
 *
 * Alter miscellaneous pages.
 */
function springboard_group_page_alter(&$page) {
  // Remove ineligible payment methods from the payments overview page.
  springboard_group_rules_payment_rules_overview__page_alter($page);
  // Add help text to the permissions overview.
  springboard_group_permissions_overview__page_alter($page);
}

/**
 * Implements hook_clone_access_alter().
 */
function springboard_group_clone_access_alter(&$access, $node) {
  springboard_group_get_user_group_ids(FALSE);
  springboard_group_get_user_group_ids(TRUE);

  global $user;
  if (empty($user->uid)) {
    return;
  }
  $user_groups = og_get_groups_by_user();
  if (empty($user_groups['node'])) {
    return;
  }
  $context = springboard_group_get_group_context($node);
  if (!empty($context)) {
    // Check if user has create permission for the content type.
    global $user;
    $account = $user;
    $perms = springboard_group_get_group_member_perms($context, $account);
    if (!empty($perms)) {
      $node_access = in_array('create ' . $node->type . ' content', array_keys($perms));
      if (!user_access('administer group') && empty($node_access)) {
        $access = FALSE;
      }
    }

    // Check if the node is in the user's group.
    if (!user_access('administer group') && !in_array($context, $user_groups['node'])) {
      $access = FALSE;
    }
  }
}


function springboard_group_get_user_group_ids($check_admin = TRUE) {
  $groups = &drupal_static(__FUNCTION__ . $check_admin);
  if (!isset($groups)) {
    if (user_access('administer group') && $check_admin) {
      $groups = springboard_group_get_all_springboard_groups();
    }
    else {
      $groups = og_get_groups_by_user(NULL, 'node');
    }
  }
  return $groups;
}

/**
 * Implements hook_help().
 */
function springboard_group_help($path, $arg) {

  $build = [];
  $build['#prefix'] = '<div id="springboard-group-help">';
  $build['#suffix'] = '</div>';
  $build['#attached']['css'][] = drupal_get_path('module', 'springboard_group') . '/css/springboard-og-admin.css';

  $build['#markup'] = <<<EOT
 <h2>Permissions</h2>

<p>There are two types of permissions: those granted by Springboard roles,
 and those granted by Group roles.

<h3>Administer Groups Permissions</h3>

<p>The the ability to create and/or administer all groups is conferred by
Springboard role permissions.

<p>A user in a Springboard role with the permission "Administer Organic Groups"
may post and edit content in any group, and administer all groups. He does
not need to be a member of the group.</p>

<p>A user in a Springboard role with the permission "Create/Edit/Delete
Springboard Group" may create and edit Springboard Groups. The user who
creates the group is also automatically added to the Group role
"Administrator Member."</p>

<H3>Content Permissions</h3>

<p>The ability to create or edit content is conferred by
Springboard role permissions and by Group role permissions.

<p>Please note that users with the "Administer Organic Groups" or
"Bypass content access control" Springboard role permissions are
exempt from Group content permissions.

<h4>Create Content Permissions</h4>

<p>Behavior can vary depending on settings with Groups Permissions
and within Springboard Permissions.</p>

<p>Examples:
<div class="item-list">
<ul>
<li>If a user has "create page content" permission inside a group
but not in Springboard, the user will only be able to create page
content for that group.
<li>If a user has "create page content"
permission in Springboard and within a group, the user can choose to
post to the group or outside the group.
<li>If a user has "create page content"
permission in Springboard but not within a group, the user cannot
post to a group.
</ul></div>

<h4>Edit and Delete Content Permissions</h4>

<b>Strict access enabled</b>
<p>Group permissions override Springboard permissions.
This is the recommended setting.
<p>Examples:
<ul><li>A content editor with the global Springboard permission “Edit any
page content” would be denied access to
modifying page content if that page is in a group to which he does
not belong, or in which he does not have edit rights.</li>
 <li>A content editor with the global Springboard permission “Edit own page content”
 would be denied access to modifying his own page content if that page has been
  added to a group to which he does not belong, or in which
  he does not have edit rights.</li>
 </ul>

<b>Strict access disabled</b>: <br>
<p>Group permissions do not override Springboard permissions.
<p>Examples:
<ul><li>A content editor with the global Springboard permission “Edit any
page content” would be able to modify any page content even if that page is
in a group to which he does not belong. The page would be removed from
the group when re-saved.</li>

<li>A content editor with the global Springboard permission “Edit own page content”
 would be able to modify his own page content if that page has been
  added to a group to which he does not belong. The page would be removed
  from the group when re-saved.</li>
 </ul>
<h4>Super-user Permissions</h4>


<p><strong>Content access</strong>: any user in a Springboard role with the "Bypass content access control"
permission will be exempt from content access control. To prevent conflicts
with group ownership when saving content, every role that has
"Bypass content access control" must also have "Administer Organic groups"
permissions.</p>
<p><strong>Rules access: </strong> any user in a Springboard role with the "Bypass rules access control"
permission will be exempt from rules access control. To prevent conflicts
with group ownership when saving payment methods, every role that has
"Bypass rules access control" should also have "Administer Organic groups"
permissions.</p>
<p>Any user in a Springboard role with the "Administer rules configurations"
permission will be exempt from rules access control. To prevent conflicts
with group ownership when saving payment methods, every role that has
"Administer rules configurations" should also have "Administer Organic groups"
permissions.</p><br />

EOT;

  $output = '';
  switch ($path) {
    case 'admin/help#springboard_group':
      $output = drupal_render($build);
      break;

    case 'admin/springboard/groups/settings/help':
      $output = $build;
      break;
  }
  return $output;
}


function springboard_group_springboard_advocacy_user_can_access_type($type) {
  $access = springboard_group_user_can_access_type_in_group($type);
  return $access;
}

function springboard_group_springboard_admin_access_donation_form_pages($types) {
  if (is_array($types)) {
    foreach ($types as $type) {
      if (fundraiser_is_donation_type($type)) {
        if(springboard_group_user_can_access_type_in_group($type)) {
          return TRUE;
        }
      }
    }
  }
  else {
    if (fundraiser_is_donation_type($types)) {
      if (springboard_group_user_can_access_type_in_group($types)) {
        return TRUE;
      }
    }
  }
}

function springboard_group_springboard_admin_access_form_pages($types) {
  if (is_array($types)) {
    foreach ($types as $type) {
      if (!fundraiser_is_donation_type($type)) {
        if(springboard_group_user_can_access_type_in_group($type)) {
          return TRUE;
        }
      }
    }
  }
  else {
    if (!fundraiser_is_donation_type($types)) {
      if(springboard_group_user_can_access_type_in_group($types)) {
        return TRUE;
      }
    }
  }
}

function springboard_group_springboard_admin_access_marketing_overview() {

}

function springboard_group_springboard_admin_access_integration_overview() {

}

function springboard_group_user_can_access_type_in_group($type, $account = NULL) {
  $access = FALSE;
  global $user;
  if (empty($account)) {
    $account = $user;
  }
  $groups = og_get_entity_groups('user', $account);
  if (!empty($groups['node'])) {
    foreach ($groups['node'] as $gid) {
      if ($roles = og_get_user_roles('node', $gid)) {
        $perms = og_role_permissions($roles);
        $role_permissions = [];
        foreach ($perms as $perm) {
          $role_permissions = array_merge($role_permissions, array_keys(array_filter($perm)));
        }
        $content_perms = array(
          'create ' . $type . 'content',
          'update any ' . $type . ' content',
        );
        foreach ($content_perms as $content_perm) {
          if (in_array($content_perm, $role_permissions)) {
            $access = TRUE;
          }
        }
      }
    }
  }
  return $access;
}

/**
 * Implements hook_module_implements_alter().
 */
function springboard_group_module_implements_alter(&$implementations, $hook) {
  if ($hook == 'menu_alter') {
    $group = $implementations['springboard_group'];
    unset($implementations['springboard_group']);
    $implementations['springboard_group'] = $group;
  }
}

/**
 * Implements hook_form_node_type_form_alter().
 */
function springboard_group_form_node_type_form_alter(&$form, &$form_state) {
  // Don't allow group settings visible on node type forms because it
  // doesn't set the correct handler or field name for springboard groups.
  if (isset($form['og'])) {
    $form['og']['#access'] = FALSE;
  }
}
