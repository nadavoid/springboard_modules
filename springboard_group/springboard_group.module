<?php

/**
 * @file
 * Springboard Group integration with Organic Groups.
 */

require_once __DIR__ . '/includes/springboard_group.field_groups.inc';
require_once __DIR__ . '/includes/springboard_group.fields.inc';
require_once __DIR__ . '/includes/springboard_group.menu.inc';
require_once __DIR__ . '/includes/springboard_group.rules.inc';
require_once __DIR__ . '/includes/springboard_group.permissions.inc';
require_once __DIR__ . '/includes/springboard_group.pages_default.inc';
require_once __DIR__ . '/includes/springboard_group.og_context.inc';
require_once __DIR__ . '/includes/springboard_group.webform_ab.inc';
require_once __DIR__ . '/includes/springboard_group.page_wrappers.inc';
require_once __DIR__ . '/includes/springboard_group.email_wrappers.inc';
require_once __DIR__ . '/includes/springboard_group.fundraiser.inc';
require_once __DIR__ . '/includes/springboard_group.entityreference.inc';

/**
 * Implements hook_node_info().
 *
 * Define the content type Springboard Group. OG lets you turn any entity
 * into a group, but Springboard Groups is specifically geared to this
 * content type.
 */
function springboard_group_node_info() {
  $items = array(
    'springboard_group' => array(
      'name' => t('Springboard Group'),
      'base' => 'node_content',
      'description' => '',
      'has_title' => '1',
      'title_label' => t('Title'),
      'help' => '',
      'locked' => TRUE,
    ),
  );
  return $items;
}

/**
 * Implements hook_views_api().
 */
function springboard_group_views_api() {
  return array(
    'api' => 3.0,
    'path' => drupal_get_path('module', 'springboard_group') . '/includes/views',
  );
}

/**
 * Implements hook_ctools_plugin_api().
 */
function springboard_group_ctools_plugin_api($module = NULL, $api = NULL) {
  // Needed for automatic field group installation on Springboard Group
  // content type.
  if ($module == "field_group" && $api == "field_group") {
    return array("version" => "1");
  }
  // Needed for automatic panels installation on Springboard Group
  // content type.
  if ($module == "page_manager" && $api == "pages_default") {
    return array("version" => "1");
  }
}

/**
 * Implements hook_ctools_plugin_directory().
 *
 * Extend Class OgSelectionHandler, so that admins can get groups
 * they aren't a member of displayed in the default group selector instead
 * of the "groups you aren't a member of" selector that is default with OG.
 */
function springboard_group_ctools_plugin_directory($module, $plugin) {
  if ($module == 'entityreference') {
    return "plugins/entityreference/$plugin";
  }
}

/**
 * Implements hook_ctools_plugin_post_alter().
 *
 * Allow entity reference fields to reference unpublished items,
 */
function springboard_group_ctools_plugin_post_alter(&$plugin, &$info) {
  if (
    $plugin['plugin module'] == 'entityreference'
    && $plugin['plugin type'] == 'selection'
    && $plugin['class'] == 'EntityReference_SelectionHandler_Generic'
  ) {
    $plugin = array(
      'class' => 'SpringboardGroup_EntityReference_SelectionHandler_Generic',
      'module' => 'springboard_group',
      'path' => drupal_get_path('module', 'springboard_group') . '/includes',
      'file' => 'springboard_group.entityreference.inc',
    ) + $plugin;
  }
}

/**
 * Implements hook_node_access().
 */
function springboard_group_node_access($node, $op, $account) {

  if ($op == 'view') {
    // Allow access to unpublished actions so that messages can be
    // assigned to them via entity reference prepopulate.
    if (strpos($node->type, 'sba_') !== FALSE) {
      if ($node->status == 0 && user_access('create ' . $node->type . ' content')) {
        return NODE_ACCESS_ALLOW;
      }
    }

    // Limit view access to group nodes.
    if ($node->type == 'springboard_group') {
      if (empty(og_get_groups_by_user()) && !user_access('administer group') && !user_access('create springboard_group content')) {
        return NODE_ACCESS_DENY;
      }
    }
  }

  return NODE_ACCESS_IGNORE;
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Change the default text on og_group_ref field deletion confirm page. That is
 * when making an entity un-groupable.
 */
function springboard_group_form_og_ui_field_delete_form_alter(&$form, &$form_state) {
  if ($_GET['destination'] == 'admin/springboard/groups/settings') {
    $form['actions']['cancel']['#markup'] = l(t('cancel'), 'admin/springboard/groups/settings');
    $form['description']['#markup'] = t('All group associations for the @type content type will be deleted. This cannot be undone.', array('@type' => arg(5)));
    $form['#submit'][] = 'springboard_group_form_og_ui_field_delete_submit';
  }
}

/**
 * Delete multiple choice variable when deleting its owner field.
 */
function springboard_group_form_og_ui_field_delete_submit($form, $form_state) {
  if ($_GET['destination'] == 'admin/springboard/groups/settings') {
    variable_del('og_' . $form_state['values']['bundle'] . '_multiple');
  }
}

/**
 * Get a list of groupable entity types.
 *
 * Checks to see what entity types have an OG group reference field.
 *
 * @return array
 *   An array of groupable entites.
 */
function springboard_group_get_grouped_types() {
  $groups_enabled = &drupal_static(__FUNCTION__);
  if (!isset($groups_enabled)) {
    // Get the fields that exist in the bundle.
    foreach (field_info_fields() as $field_name => $field) {
      if ($field['type'] == 'entityreference' && $field['settings']['handler'] == 'og_springboard_og' && !empty($field['bundles'])) {
        foreach ($field['bundles'] as $entity_type => $bundles) {
          foreach ($bundles as $bundle) {
            $groups_enabled[$entity_type][$bundle][] = $field_name;
          }
        }
      }
    }
  }
  return $groups_enabled;
}

/**
 * Implements hook_form_FORMID_alter().
 *
 * Alter the form on the springboard group content type.
 */
function springboard_group_form_springboard_group_node_form_alter(&$form, &$form_state) {
  // Change some of the defaults on the addressfield.
  if (!empty($form['field_sb_group_address'])) {
    $form['field_sb_group_address']['#type'] = 'fieldset';
    $form['field_sb_group_address']['#collapsible'] = TRUE;
    $form['field_sb_group_address']['#collapsed'] = TRUE;
    $form['field_sb_group_address']['#title'] = t('Address');
    $form['field_sb_group_address'][$form['field_sb_group_address']['#language']][0]['#title'] = '';
  }
}

/**
 * Implements hook_form_node_form_alter().
 */
function springboard_group_form_node_form_alter(&$form, &$form_state) {

  $fields = og_get_group_audience_fields('node', $form['#node']->type, 'node', 'springboard_group');
  if (!empty($fields)) {

    // Change the group field from a multiple select to a single select.
    springboard_group_set_single_selector($form, $fields);

    // Add ajax callback to the groups field so we can validate newly
    // selected groups.
    $language = $form['og_group_ref_' . substr($form['#node']->type, 0, 19)]['#language'];
    $form['og_group_ref_' . substr($form['#node']->type, 0, 19)][$language][0]['default']['#ajax'] = array(
      'callback' => 'springboard_group_ajax_callback',
    );

    springboard_group_entityreference_context($form, $form_state);

    // Set up the validation modal window parameters.
    springboard_group_prepare_validation_modal($form, $form_state);

    // Add the validation handler to the form.
    springboard_group_load_ajax_validation_handlers($form, $form_state);

  }
}

/**
 * Ajax Callback.
 *
 * Handles pagewrappers and payment gateway selector updates when the group
 * selector is changed on node edit forms.
 *
 * Displays message in a cTools modal when a new group selection conflicts
 * with an entity's grouped-owned assets: page wrappers, email wrappers, message
 * targets, ab tests, and vice versa.
 */
function springboard_group_ajax_callback(&$form, &$form_state) {

  $ajax = array(
    '#type' => 'ajax',
    '#commands' => array(),
  );

  // Update the pagewrapper fieldset.
  if (!empty($form['springboard_display']['page_wrappers_settings']['page_wrappers'])) {
    $ajax['#commands'][] = ajax_command_replace("#page-wrappers-assignments", render($form['springboard_display']['page_wrappers_settings']['page_wrappers']));
  }

  // Update the entire gateways fieldset.
  if (!empty($form['payment_methods']['gateways'])) {
    $ajax['#commands'][] = ajax_command_replace("#springboard-groups-payment-ajax-wrapper", render($form['payment_methods']['gateways']));
  }

//  if (!empty($form['#fieldgroups']['group_tabs'])) {
//    $ajax['#commands'][] = ajax_command_replace("#field-group-htabs-wrapper ", render($form['#fieldgroups']['group_tabs']));
//  }

  // Show messages about conflicting page assets after a new group is selected.
  $messages = $form_state['group_ajax_messages'];
  if (!empty($messages)) {
    $list = implode('<br /><br />', $form_state['group_ajax_messages']);
    $ajax['#commands'][] = ctools_modal_command_display(t('Group asset update'), $list);
  }

  return $ajax;
}


/**
 * Prepare the validation modal window.
 */
function springboard_group_prepare_validation_modal(&$form, &$form_state) {
  // Set up our group validation modal message window which will display after
  // ajax reload if there is a group conflict.
  ctools_include('modal');
  ctools_modal_add_js();
  $settings['CToolsModal']['modalSize'] = array(
    'type' => 'scale',
    'width' => .8,
    'height' => .8,
  );
  $settings['CToolsModal']['modalOptions'] = array(
    'opacity' => '.55',
    'background' => '#ccc',
  );
  drupal_add_js($settings, 'setting');
  $form_state['group_ajax_messages'] = [];
}

/**
 * Add the validation handlers to the node form.
 */
function springboard_group_load_ajax_validation_handlers(&$form, &$form_state) {

  $type = $form['#node']->type;
  $callback = !empty($form_state['triggering_element']['#ajax']['callback']) ? $form_state['triggering_element']['#ajax']['callback'] : '';

  if (fundraiser_is_donation_type($type)) {
    springboard_group_fundraiser_node_form_gateway_validate($form, $form_state);
  }

  if ($callback == 'springboard_group_ajax_callback') {
    if (module_exists('page_wrappers') && (_page_wrappers_enabled_type($form['#node']) || $type == 'page_wrapper')) {
      springboard_group_node_form_page_wrappers_validate($form, $form_state);
    }
    $webform_types = variable_get('webform_node_types');
    if (module_exists('email_wrappers') && in_array($type, $webform_types)) {
      springboard_group_node_form_email_wrappers_validate($form, $form_state);
    }
    if (module_exists('webform_ab') && ($type == 'webform_ab' || in_array($type, $webform_types))) {
      springboard_group_node_form_webform_ab_validate($form, $form_state);
    }
    if (module_exists('springboard_group_advocacy') && springboard_advocacy_is_action_type($type)) {
      springboard_group_advocacy_action_targets_validate($form, $form_state);
    }
  }
}

/**
 * Implements hook_field_widget_form_alter().
 *
 * Instead of having a separate "mock" field for "groups you don't belong to"
 * we'll put all options in the main widget for sufficiently permissioned
 * national group admin. Need to do this because we're not allowing
 * multiple selections on the group reference fields.
 *
 * @see OgSpringboardOgSelectionHandler
 * @see og_field_widget_form()
 */
function springboard_group_field_widget_form_alter(&$element, &$form_state, $context) {

  if (isset($context['field']['settings']['handler']) && $context['field']['settings']['handler'] == 'og_springboard_og') {
    // If the og reference field is using our custom selection handler,
    // remove the admin "groups you are not of member of" field.
    $element['admin']['#access'] = FALSE;
    // Set the value of the default field to the default value of the admin
    // field if there are values present.
    if (!empty($element['admin']['#default_value']) && empty($element['default']['#default_value'])) {
      $element['default']['#default_value'] = $element['admin']['#default_value'];
    }
    $element['admin']['#default_value'] = [];
  }
}

/**
 * Change the group field from a multiple select to a single select.
 *
 * Doing it here instead of in field config allows us to preserve an
 * unlimited cardinality, which OG basically always assumes is the case.
 * Limiting the cardinality to 1 would cause errors when different users
 * attempt to reassign a node to a different group when it has a membership
 * already assigned by different user, even though the original record in the
 * og_membership table would be removed.
 *
 * @param array $form
 *   The form on which the group selector appears.
 * @param array $fields
 *   An array of group reference fields.
 */
function springboard_group_set_single_selector(&$form, $fields) {
  foreach ($fields as $key => $field) {
    $field_name = $key;
    $grouped_entities = springboard_group_get_grouped_types();
    foreach ($grouped_entities as $entity => $bundle) {
      foreach ($bundle as $bundle_name => $og_field) {
        if (in_array($key, $og_field)) {
          $form[$field_name]['#type'] = 'fieldset';
          $form[$field_name]['#collapsible'] = TRUE;
          $form[$field_name]['#collapsed'] = FALSE;
          $form[$field_name]['#title'] = variable_get('springboard_group_name', t('Springboard Groups'));
          $form[$field_name][$form[$field_name]['#language']]['#title'] = '';
          $form[$field_name][$form[$field_name]['#language']][0]['default']['#title'] = t('Group');
          $form[$field_name][$form[$field_name]['#language']][0]['default']['#description'] = t('Associate this content with a group.');
          $form[$field_name][$form[$field_name]['#language']][0]['default']['#multiple'] = variable_get('og_' . $bundle_name . '_multiple', 0);
        }
      }
    }
  }
}

/**
 * Implements hook_preprocess_page().
 *
 * Adds a group dropdown selector to designated non-node pages when a user
 * has multiple group affilaitions. See springboard_group_context_menu_paths()
 * for a list of paths this is active on.
 */
function springboard_group_preprocess_page(&$vars) {
  $path = current_path();
  $og_paths = springboard_group_context_menu_paths();
  if (in_array($path, $og_paths) && isset($_SESSION['springboard_group_context_multiple'])) {
    $build = array(
      'selector' => drupal_get_form('springboard_group_group_selector_form', $_SESSION['springboard_group_context_multiple']),
    );
    $vars['page']['content']['system_main']['group_selector']['#markup'] = render($build);
    $vars['page']['content']['system_main']['group_selector']['#weight'] = -10;
    $vars['page']['content']['system_main']['group_selector']['#prefix'] = '<div id="sb-og-group-group_selector">';
    $vars['page']['content']['system_main']['group_selector']['#suffix'] = '</div>';
  }
}

/**
 * Build the group selector form.
 *
 * Pages without a node context need a way of determining which group is
 * active. This adds a selector to choose which group
 * context to work in.
 *
 * @param array $groups
 *   The current user's possible groups.
 *
 * @return array
 *   The form.
 */
function springboard_group_group_selector_form($form, &$form_state, $groups) {

  $form = [];
  $form['title']['#markup'] = '<strong>' . t('Choose an affiliate group to work in:') . '</strong>';

  // Build the selector form from groups found in user session.
  $options = [];
  if (user_access('administer group')) {
    $options['_none'] = '- None -';
  }
  foreach ($groups as $nid) {
    $node = node_load($nid);
    $options[$nid] = check_plain($node->title);
  }

  // The ajax enabled group selector which will reload the page
  // subsequent to a group choice. The group ID will get put into session.
  $form['groups'] = array(
    '#type' => 'select',
    '#options' => $options,
    '#default_value' => springboard_group_get_group_context(),
    '#ajax' => array(
      'callback' => 'springboard_group_group_selector',
      'wrapper' => 'sb-og-group-selector',
      'method' => 'replace',
      'effect' => 'fade',
    ),
    '#prefix' => '<div id="group-selector-div">',
    '#suffix' => '</div>',
  );

  return $form;
}

/**
 * AJAX callback for group selector form.
 */
function springboard_group_group_selector($form, &$form_state) {
  // Put the chosen group into session, so it can be retrieved by
  // springboard_group_advocacy_og_context_handler().
  $_SESSION['springboard_group_working_group'] = $form_state['values']['groups'];

  // Reload the page to get the new grouped content.
  ctools_include('ajax');
  ctools_add_js('ajax-responder');
  $commands[] = ctools_ajax_command_reload();
  print ajax_render($commands);
  drupal_exit();
}

/**
 * Implements hook_TAG_query_alter().
 *
 * Don't allow groups in search results for unprivileged users.
 */
function springboard_group_query_node_access_alter(QueryAlterableInterface $query) {

  if (!empty(og_get_groups_by_user()) || user_access('administer group') || empty($query->alterTags['search_node'])) {
    return;
  }

  $search = FALSE;
  $node = FALSE;

  foreach ($query->getTables() as $alias => $table) {
    if ($table['table'] == 'search_index') {
      $search = $alias;
    }
    elseif ($table['table'] == 'node') {
      $node = $alias;
    }
  }

  if ($node && $search) {
    $excluded_content_types = array('springboard_group');
    if (!empty($excluded_content_types)) {
      $query->condition($node . '.type', array($excluded_content_types), 'NOT IN');
    }
  }
}

/**
 * Implements hook_og_ui_get_group_admin().
 *
 * Remove the permissions and roles links for the group node's group tab.
 */
function springboard_group_og_ui_get_group_admin_alter(&$data, $context) {
  if ($context['entity_type'] == 'node') {
    $node = node_load($context['etid']);
    if ($node->type == 'springboard_group') {
      unset($data['permissions']);
      unset($data['roles']);
    }
  }
}

function springboard_group_page_alter(&$page) {
  springboard_group_rules_page_filter_payment_rules($page);
  springboard_group_permissions_overview_page($page);
}